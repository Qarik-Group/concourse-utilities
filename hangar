#!/bin/bash

VERSION=1.1.0

USERNAME=$(whoami)
CANON_REPO=https://github.com/starkandwayne/hangar
HANGAR_DIR="${HOME}/.hangar"
FLY_CMD="${HANGAR_DIR}/fly"

# Options
opt_target=${CONCOURSE_TARGET}
opt_pause_after_restore='a'
opt_backup_dir="${HANGAR_DIR}/backups"
opt_clean=""
target_pipelines=()

####################################################
# pipelines and backups info

declare -a pipelines pipeline_states

get_pipelines() {
  local pipeline_info
  local name
  local state

  pipeline_info="$(${FLY_CMD} -t $opt_target pipelines)"
  if [[ "$?" -ne 0 ]]
  then
    fatal \
      "Could not retrieve pipelines from $opt_target:" \
      $pipeline_info
    exit 1
  fi

  pipelines=()
  pipeline_states=()
  while read name state
  do
    pipelines+=("$name")
    pipeline_states+=("$state")
  done < <(echo "$pipeline_info" | tail -n +1)
}

declare -a backups backup_states

get_backups() {
  local backup_files
  local name
  local state

  echo "backup dir: $opt_backup_dir"

  shopt -s nullglob
  backup_files=(${opt_backup_dir}/*.yml)
  shopt -u nullglob
  backups=()
  backup_states=()
  for file in "${backup_files[@]}"
  do
    name="$( echo "$file" | sed -E 's#.*/([^/]*)\.yml$#\1#' )"
    if [[ -f "${opt_backup_dir}/${name}.state" ]]
    then
      state="$(cat ${opt_backup_dir}/${name}.state)"
    else
      state="unknown"
    fi

    backups+=("$name")
    backup_states+=("$state")
  done
}

pipeline_state() {
  name=$1
  index="$(echo ${pipelines[@]/${name}//} | cut -d/ -f1 | wc -w | tr -d ' ')"
  echo "${pipeline_states[$index]}"
}

pipeline_exists() {
  name=$1
  index="$(echo ${pipelines[@]/${name}//} | cut -d/ -f1 | wc -w | tr -d ' ')"
  [[ $index -lt ${#pipelines[@]} ]]
}

backup_state() {
  name=$1
  index="$(echo ${backups[@]/${name}//} | cut -d/ -f1 | wc -w | tr -d ' ')"
  echo "${backup_states[$index]}"
}

backup_exists() {
  name=$1
  index="$(echo ${backups[@]/${name}//} | cut -d/ -f1 | wc -w | tr -d ' ')"
  [[ $index -lt ${#backups[@]} ]]
}


####################################################
# checks and validating functions

need_command() {
  local cmd=${1:?need_command() - no command name given}

  [[ -x "$(command -v $cmd)" ]] || fatal "${cmd} is not installed."
}

check_target() {
  [[ -n "$opt_target" ]] || fatal "No target specified.  Please set in \$CONCOURSE_TARGET or use the -t|--target option"

  yaml="$(parse_yaml ~/.flyrc fly_)"
  fly_url="$(echo "$yaml" | grep fly_targets_${opt_target}_api | sed -E 's/^.*?="(.*)"$/\1/')"

  results="$(curl -sS ${fly_url})"
  [[ $? -eq 0 ]] || fatal "Cannot reach Concourse target at ${fly_url}"
}

check_backup_directory_empty() {
  shopt -s nullglob
  files=(${opt_backup_dir}/*.{yml,state})
  [[ "${#files[@]}" -eq 0 ]] || fatal "Backup directory (${opt_backup_dir}) cannot contain any .yml or .state files"
}

need_dirs() {
  [[ -d "$HANGAR_DIR" ]] || mkdir -p "${HANGAR_DIR}"
  [[ -n "$opt_backup_dir" ]] || fatal "No backup directory specified"
  mkdir -p -- "$opt_backup_dir"
}

need_fly() {

  echo "Ensuring ${FLY_CMD} to the matching version for the target"
  yaml="$(parse_yaml ~/.flyrc fly_)"
  fly_url="$(echo "$yaml" | grep fly_targets_${opt_target}_api | sed -E 's/^.*?="(.*)"$/\1/')"
  fly_token_type="$(echo "$yaml" | grep fly_targets_${opt_target}_token_type | sed -E 's/^.*?="(.*)"$/\1/')"
  fly_token="$(echo "$yaml" | grep fly_targets_${opt_target}_token_value | sed -E 's/^.*?="(.*)"$/\1/')"

  fetch_manually=true
  if [[ "$fly_token_type" == "Bearer" ]]
  then
    curl -sS "${fly_url}/api/v1/cli?arch=amd64&platform=linux" -o ${FLY_CMD} -H "Authorization: Bearer $fly_token"

    if [[ ! "$(file "${FLY_CMD}")" =~ ASCII\ text ]]
    then
      echo "Retrieved!"
      echo ""
      fetch_manually=false
      chmod u+x  ${FLY_CMD}
    fi
  fi

  if [[ "$fetch_manually" == "true" ]]
  then
    echo "Could not fetch fly -- need to log in with HTTP Basic Auth"
    read -p "username: " username
    read -p "password: " -s password
    auth="$username:$password"
    curl -sS "${fly_url}/api/v1/cli?arch=amd64&platform=linux" --basic --user $auth -o ${FLY_CMD}
    if [[ "$(file "${FLY_CMD}")" =~ ASCII\ text ]]
    then
      rm ${FLY_CMD}
      fatal "Could not log into Concourse to fetch fly!"
    fi
    chmod u+x  ${FLY_CMD}
    echo ""
    echo "Successfully fetched"
  fi

  test="$(${FLY_CMD} -t ${opt_target} workers 2>&1)"
  if [[ "$test" =~ not\ authorized ]]
  then
    echo "Log into Concourse"
    ${FLY_CMD} -t $opt_target login -k
  fi

  [[ -x  ${FLY_CMD} ]] || fatal "ERROR: ${FLY_CMD} not found or not executable -- cannot continue."
}


####################################################
# parser functions

parse_opts() {
  local arg
  while (( $# )); do
    arg=$1 ; shift
    case ${arg} in
    (-t|--target)
      opt_target="$1"
      shift
      ;;
    (-p|--path)
      opt_backup_dir="$1"
      shift
      ;;
    (*)
      cmd_opt_parser="${action}_opt_parser"
      offset=0
      if command -V $cmd_opt_parser | grep "is a function" 2>/dev/null 1>&2
      then
        $cmd_opt_parser $arg $*
      fi
      [[ "$offset" -gt 0 ]] || fatal "Unknown option '$arg'"
      while (( offset = offset - 1 ))
      do
        shift
      done
      ;;
    esac
  done
}

cmd_backup_opt_parser() {
  local arg
  arg=$1 ; shift
  case ${arg} in
    (-P|--pause)
      opt_pause_first=true
      offset=1
      ;;
    (-c|--clean)
      opt_clean=true
      offset=1
      ;;
    (-*)
      offset=0
      ;;
    (*)
      target_pipelines+=($arg)
      offset=1
      ;;
  esac
}

cmd_restore_opt_parser() {
  local arg
  local opt
  arg=$1 ; shift
  case ${arg} in
    (-P|--pause)
      opt=$1
      case ${opt} in
        (y|yes|n|no|a|auto)
          opt_pause_after_restore="${opt:0:1}"
          ;;
        (*)
          fatal "Error: $arg expects (y)es, (n)o or (a)uto"
          ;;
      esac
      offset=2
      ;;
    (-c|--clean)
      opt_clean=true
      offset=1
      ;;
    (--missing)
      opt_restore_missing=true
      offset=1
      ;;
    (-*)
      offset=0
      ;;
    (*)
      target_pipelines+=($arg)
      offset=1
      ;;
  esac
}

####################################################
# common functions used by other parts of hangar

fatal() {
  for msg in "$@"
  do
    echo >&2 $msg
  done
  exit 1
}

parse_yaml() {
   local prefix=$2
   local s='[[:space:]]*' w='[-a-zA-Z0-9_]*' fs=$(echo @|tr @ '\034')
   sed -ne "s|^\($s\)\($w\)$s:$s\"\(.*\)\"$s\$|\1$fs\2$fs\3|p" \
        -e "s|^\($s\)\($w\)$s:$s\(.*\)$s\$|\1$fs\2$fs\3|p"  $1 |
   awk -F$fs '{
      indent = length($1)/2;
      vname[indent] = $2;
      for (i in vname) {if (i > indent) {delete vname[i]}}
      if (length($3) > 0) {
         vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("_")}
         printf("%s%s%s=\"%s\"\n", "'$prefix'",vn, $2, $3);
      }
   }'
}



####################################################
# multi-call handlers

cmd_help() {
  local topic=${1:-usage}

  case ${topic} in
  (usage)
    cat >&2 <<EOF
USAGE: hangar <command> [arguments]

Common commands:

    hangar clean               Expunge the given (or default) backup directory

    hangar backup              Backup all pipelines

    hangar refresh             Restore pipelines

    hangar inventory           List the backed up pipelines (inv for short)

    hangar help                Peruse the help!  Give it a topic argument, or the name
                               of another command to get more detailed information.
                               Documentation!

Common options:

    -t | --target <name>      Specify the target concourse.  By default, it will
                              use the value in \$CONCOURSE_TARGET if available.

    -p | --path <path>        Specify the backup path for storage or source for
                              restoring.  By default, it is set to ~/.hangar/backups

EOF
    exit 0
    ;;
  (clean)
    cat >&2 <<EOF
USAGE: hangar backup <options> <pipelines...>

Cleans out the backups from the backup directory

EOF
    exit 0
    ;;
  (backup)
    cat >&2 <<EOF
USAGE: hangar backup <options> <pipelines...>

Retrieves the pipelines from concourse, and stores them in the backup directory,
including the paused state of the backup.  If pipelines are specified, only those
pipelines will be backed up.

Options:
  -P | --pause                Pause the pipeline to be backed up before backing it up

  -c | --clean                Clean the backup directory before fetching the backups.
                              NOTE:  The backup directory has to be empty before
                                     the backups are taken.
EOF
    exit 0
    ;;
  (restore)
    cat >&2 <<EOF
USAGE: hangar restore <options> <pipelines...>

Restores the pipelines from the backup directory to concourse.  If pipelines are
specified, only those pipelines will be restored.

Options:
  --missing                   Only restore pipelines that aren't present on the
                              target concourse.

  -c | --clean                Remove the backups after restoring them.

  -P | --pause (yes|no)       Pause or unpause the restored pipeline after restoring
                              it.  'yes' and 'no' can be abbreviated as 'y' and 'n'
                              respectively.  By default, the pipelines will be
                              paused only if they were paused prior to being backed
                              up, otherwise they will be unpaused.

EOF
    exit 0
    ;;
  (*)
    cat >&2 <<EOF
Unrecognized help topic '${topic}'.
Try one of these:

    hangar help usage
    hangar help <command>

EOF
    exit 0
    ;;
  esac
  exit 1
}

cmd_clean() {

  local backup

  need_dirs
  get_backups

  for backup in ${backups[@]}
  do
    rm $opt_backup_dir/$backup.yml
    rm $opt_backup_dir/$backup.state
  done
  backups=()
}

cmd_backup() {

  local pipeline
  local result

  need_dirs
  check_target
  need_fly

  if [[ -n "$opt_clean" ]]
  then
    cmd_clean
  fi

  check_backup_directory_empty

  get_pipelines
  if [[ ${#target_pipelines[@]} -gt 0 ]]
  then
    for pipeline in "${target_pipelines[@]}"
    do
      if ! pipeline_exists $pipeline
      then
        fatal "$pipeline does not exist on specified Concourse target"
      fi
    done
  else
    target_pipelines=("${pipelines[@]}")
  fi

  echo "Backing up pipelines"
  for pipeline in "${target_pipelines[@]}"
  do
    if [[ -n "$opt_pause_first" ]]
    then
      if [[ "$(pipeline_state $pipeline)" == "yes" ]]
      then
        echo "  * ${pipeline} is already paused."
      else
        echo -n "  * Pausing ${pipeline} first..."
        result="$(${FLY_CMD} -t "$opt_target" pause-pipeline -p $pipeline)"
        if [[ "$?" -ne 0 ]]
        then
          fatal "Could not pause pipeline ${pipeline}: $result"
        fi
        echo 'done!'
      fi
    fi
    echo -n "  * Fetching ${pipeline}..."
    result="$(${FLY_CMD} -t "$opt_target" get-pipeline -p $pipeline)"
    if [[ "$?" -ne 0 ]]
    then
      fatal "Could not fetch pipeline ${pipeline}: $result"
    fi
    echo "$result" > ${opt_backup_dir}/${pipeline}.yml
    pipeline_state $pipeline > ${opt_backup_dir}/${pipeline}.state
    echo 'done!'
    echo ""
  done
}

cmd_restore() {

  local pipeline
  local result
  local desc

  need_dirs
  check_target
  need_fly

  echo "Restoring backups to $opt_target"
  get_backups
  if [[ ${#target_pipelines[@]} -gt 0 ]]
  then
    for pipeline in "${target_pipelines[@]}"
    do
      backup_exists $pipeline || fatal "$pipeline does not exist on specified Concourse target"
    done
  elif [[ -n "$opt_restore_missing" ]]
  then
    local missing_pipelines=()
    get_pipelines
    for pipeline in "${backups[@]}"
    do
      if ! pipeline_exists $pipeline
      then
        missing_pipelines+=($pipeline)
      fi
    done
    target_pipelines=("${missing_pipelines[@]}")
  else
    target_pipelines=("${backups[@]}")
  fi

  if [[ "${#target_pipelines[@]}" -eq 0 ]]
  then
    echo "No pipelines to restore"
    return
  fi

  for pipeline in "${target_pipelines[@]}"
  do
    echo -n "  * Uploading ${pipeline}..."
    result="$(${FLY_CMD} -t "$opt_target" set-pipeline -n -p $pipeline -c ${opt_backup_dir}/${pipeline}.yml)"
    [[ "$?" -eq 0 ]] || fatal "Could not set pipeline ${pipeline}: $result"
    echo 'done!'

    local pause_cmd
    pipeline_state="$(cat "${opt_backup_dir}/${pipeline}.state")"
    case ${opt_pause_after_restore/a/$pipeline_state} in
      (y|yes)
        pause_cmd="pp"
        desc="Pausing"
        ;;
      (n|no)
        pause_cmd="up"
        desc="Unpausing"
        ;;
      (*)
        pause_cmd=""
        ;;
    esac
    if [[ -n "$pause_cmd" ]]
    then
      echo -n "  * ${desc} ${pipeline}..."
      result="$(${FLY_CMD} -t "$opt_target" $pause_cmd -p $pipeline)"
      [[ "$?" -eq 0 ]] || fatal "$desc pipeline ${pipeline} failed: $result"
      echo 'done!'
    fi

    if [[ -n "$opt_clean" ]]
    then
      echo "  * Removing backup"
      rm ${opt_backup_dir}/${pipeline}.yml
      rm ${opt_backup_dir}/${pipeline}.state
    fi
    echo ""

  done
}

cmd_inv() {

  local pipeline
  local result

  need_dirs
  check_target
  need_fly

  get_backups

  echo "Date              Paused  Name"
  echo "----------------  ------  --------------------------------------------------------------"
  for pipeline in "${backups[@]}"
  do
    ts="$(date -d "$(stat -c "%z" ${opt_backup_dir}/${pipeline}.yml)" +"%Y-%m-%d@%H:%M")"
    pipeline_state="$(cat "${opt_backup_dir}/${pipeline}.state")"
    printf "%-18s%-8s%s\n" "$ts" "$pipeline_state" "$pipeline"
  done
}

bad_command() {
  local cmd=${1}
  cat >&2 <<EOF
Unrecognized sub-command: '$cmd'

Try one of these:

   hangar help
   hangar version
   hangar clean
   hangar backup
   hangar restore

EOF
  exit 1
}

checksum() {
  if [[ -z $(command -v sha1sum) ]]; then
    shasum "$@"
  else
    sha1sum "$@"
  fi
}

####################################################
# multi-call interface

main() {
  local cmd_name=${1:-help} ; shift
  action=''

  case ${cmd_name} in
  (ping)
    exit 0
    ;;
  (version|-v|--version)
    s=$(cat ${BASH_SOURCE[0]} | checksum)
    echo "hangar v${VERSION} (${s:0:12})"
    exit 0
    ;;
  (help|-h|--help|-?)
    cmd_help $*
    exit 0
    ;;
  (clean)
    # Delete all existing backups
    action=cmd_clean
    ;;
  (backup)
    # Backup the pipelines
    action=cmd_backup
    ;;
  (restore)
    # Restore the pipelines
    action=cmd_restore
    ;;
  (inv|inventory)
    # List the contents of the hanger
    action=cmd_inv
    ;;
  esac
  [[ -n "${action}" ]] || bad_command ${cmd_name}

  parse_opts $@
  $action
}

main $@

echo ""
# fin
